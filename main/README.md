# Technical documentation: `xiaozhi-esp32-server`

**Table of contents:**

1. [Introduction](#1-Introduction)
2. [Overall Architecture](#2-Overall Architecture)
3. [In-depth analysis of core components](#3-In-depth analysis of core components)
* [3.1. `xiaozhi-server` (core AI engine - Python implementation)] (#31-xiaozhi-server-core ai engine---python implementation)
* [3.2. `manager-api` (Management backend - Java Spring Boot implementation)] (#32-manager-api-Management backend---java-spring-boot implementation)
* [3.3. `manager-web` (Web management front end - Vue.js implementation)] (#33-manager-web-web management front end - vuejs implementation)
* [3.4. `manager-mobile` (mobile management terminal - uni-app+Vue3 implementation)] (#34-manager-mobile-mobile management terminal---uni-appvue3 implementation)
4. [Data flow and interaction mechanism](#4-Data flow and interaction mechanism)
5. [Core Function Summary](#5-Core Function Summary)
6. [Deployment and Configuration Overview](#6-Deployment and Configuration Overview)
---

## 1. Introduction

The `xiaozhi-esp32-server` project is a **comprehensive backend system** designed to provide support for ESP32-based smart hardware. Its core goal is to enable developers to quickly build a powerful server infrastructure that can not only understand natural language instructions, but also efficiently interact with multiple AI services (for speech recognition, natural language understanding, and speech synthesis), manage Internet of Things (IoT) devices, and provide a web-based user interface for system configuration and management. By integrating multiple cutting-edge technologies into a highly cohesive and scalable platform, this project aims to simplify and accelerate the development of customizable voice assistants and intelligent control systems. It is not just a simple server, but also a bridge connecting hardware, AI capabilities and user management.

---

## 2. Overall architecture

The `xiaozhi-esp32-server` system adopts a **distributed, multi-component collaboration** architecture design to ensure the modularity, maintainability and scalability of the system. Each core component performs its own duties and works together. Main components include:

1. **ESP32 Hardware (Client Device):**
This is a physical smart hardware device that the end user interacts with directly. Its main responsibilities include:
* Capture user's voice commands.
* Securely send the captured raw audio data to `xiaozhi-server` for processing.
* Receive the voice reply synthesized from `xiaozhi-server` and play it to the user through the speaker.
* Based on the instructions received from `xiaozhi-server`, control other peripheral devices or IoT devices (such as smart light bulbs, sensors, etc.) connected to it.

2. **`xiaozhi-server` (core AI engine - Python implementation):**
This Python-based server is the "brain" of the entire system and is responsible for handling all voice-related logic and AI interactions. Its key responsibilities are detailed as follows:
* Establish a **stable, low-latency real-time two-way communication link** with ESP32 devices through the WebSocket protocol.
* Receive audio streams from ESP32 and use Voice Activity Detection (VAD) technology to accurately segment valid voice segments.
* Integrate and call automatic speech recognition (ASR) service (configurable local or cloud) to convert speech clips into text.
* Parse user intent, generate intelligent responses, and support complex natural language understanding tasks by interacting with large language models (LLM).
* Manage contextual information and user memory across multiple rounds of dialogue to provide a coherent interactive experience.
* Call the text-to-speech (TTS) service to synthesize the text generated by LLM into natural and smooth speech.
* Execute custom commands, including control logic for IoT devices, through a flexible **plugin system**.
* Get its detailed runtime operation configuration from the `manager-api` service.

3. **`manager-api` (Management backend - Java implementation):**
This is an application built on the Java Spring Boot framework, which provides a secure RESTful API for the management and configuration of the entire system. It is not only the backend support of `manager-web` console, but also the source of configuration data of `xiaozhi-server`. Its core features include:
* Provide user authentication (login, permission verification) and user account management functions for the Web console.
* Registration, information management and device-specific configuration maintenance of ESP32 devices.
* Persistent storage of system configurations in **MySQL database**, such as user-selected AI service providers, API keys, device parameters, plug-in settings, etc.
* Provide a specific API endpoint for `xiaozhi-server` to pull the latest configuration it requires.
* Manage TTS tone options, handle OTA (Over-The-Air) firmware update process and related metadata.
* Use **Redis** as a cache to store hotspot data (such as session information, frequently accessed configurations) to improve API response speed and overall system performance.

4. **`manager-web` (Web control panel - Vue.js implementation):**
This is a single-page application (SPA) built on Vue.js, which provides a graphical and user-friendly operation interface for system administrators. Its main capabilities include:
* Conveniently configure various AI services used by `xiaozhi-server` (such as provider switching and parameter adjustment of ASR, LLM, and TTS).
* Manage platform user accounts, role assignments and permission control.
* Manage registered ESP32 devices and their related settings.
* (Potential functions) Monitor system running status, view logs, troubleshoot, etc.
* Comprehensive interaction with all backend management functions provided by `manager-api`.

5. **`manager-mobile` (Smart console mobile version - uni-app implementation):**
This is a cross-end mobile management terminal based on uni-app v3 + Vue 3 + Vite, supporting App (Android & iOS) and WeChat mini programs. Its main capabilities include:
* Provides a convenient management interface on mobile devices, which is similar to manager-web but optimized for mobile devices.
* Supports core functions such as user login, device management, and AI service configuration.
* Cross-platform adaptation, one set of code can run on iOS, Android and WeChat mini programs at the same time.
* Based on alova + @alova/adapter-uniapp to implement network requests and seamlessly integrate with manager-api.
* Use pinia for state management to ensure data consistency.

**Overview of high-level interaction process:**

* **Voice interaction main line:** **ESP32 device** captures the user's voice and transmits the audio data to **`xiaozhi-server`** in real time through **WebSocket**. After `xiaozhi-server` completes a series of AI processing (VAD, ASR, LLM interaction, TTS), it then sends the synthesized voice reply back to the ESP32 device for playback through WebSocket. All real-time interactions directly related to voice are completed on this link.
* **Management configuration mainline:** Administrators access the **`manager-web`** console through a browser. `manager-web` performs various management operations (such as modifying configurations, managing users or devices) by calling the **RESTful HTTP interface** provided by **`manager-api`**. Data is passed between the two in JSON format.
* **Configuration synchronization:** **`xiaozhi-server`** will actively pull its latest operation configuration from **`manager-api`** through HTTP requests when it is started or a specific update mechanism is triggered. This ensures that configuration changes made by administrators on the web interface are applied to the operation of the core AI engine in a timely and efficient manner.

This architectural design of **separation of front-end and back-end, and separation of core services and management services** enables `xiaozhi-server` to focus on efficient real-time AI processing tasks, while `manager-api` and `manager-web` jointly provide a powerful and easy-to-use management and configuration platform. Each component has clear responsibilities, which facilitates independent development, testing, deployment and expansion.

```
xiaozhi-esp32-server
├─ xiaozhi-server 8000 port Python language development responsible for communicating with esp32
├─ manager-web 8001 port Node.js+Vue development Responsible for providing the web interface of the console
├─ manager-api port 8002 Java language development responsible for providing the console API
└─ manager-mobile Cross-platform mobile application uni-app+Vue3 development Responsible for providing mobile version of smart console management
```

---

## 3. In-depth analysis of core components

### 3.1. `xiaozhi-server` (core AI engine - Python implementation)

`xiaozhi-server`, as the intelligent core of the system, is fully responsible for processing voice interaction, docking various AI services, and managing communication with ESP32 devices. Its design goal is to achieve efficient, flexible and scalable voice AI processing capabilities.

* **Core Goal:**
* Provide real-time voice command processing services for ESP32 devices.
* Deeply integrates various AI services, including: automatic speech recognition (ASR), large language model (LLM) for natural language understanding (NLU), text-to-speech (TTS), voice activity detection (VAD), intent recognition (Intent Recognition) and dialogue memory (Memory).
* Finely manage the conversation flow and context status between users and devices.
* Based on user instructions, execute custom functions and control Internet of Things (IoT) devices through a plug-in mechanism.
* Support dynamic configuration loading and updating through `manager-api`.

* **Core technology stack:**
* **Python 3:** As the main programming language, Python was chosen for its rich AI/ML ecological library and rapid development features.
* **Asyncio:** Python's asynchronous programming framework is the key to the high performance of `xiaozhi-server`. It is widely used to efficiently handle concurrent WebSocket connections from a large number of ESP32 devices, as well as perform non-blocking I/O operations when communicating with external AI service APIs, ensuring the server's responsiveness under high concurrency.
* **`websockets` library:** Provides a specific implementation of WebSocket server, supporting full-duplex real-time communication with ESP32 clients.
* **HTTP client (such as `aiohttp`, `httpx`):** Used to execute HTTP requests asynchronously. The main purpose is to obtain configuration information from `manager-api` and interact with the API of the cloud AI service.
* **YAML (usually via the PyYAML library):** Used to parse local `config.yaml` configuration files.
* **FFmpeg (external dependency):** Checked when `app.py` is started (`check_ffmpeg_installed()`). FFmpeg is often used for audio processing and format conversion, for example, to ensure that audio data meets the requirements of a specific AI service or for internal processing.

* **Key implementation details:**

1. **AI service provider pattern (Provider Pattern - `core/providers/`):**
* **Design Idea:** This is the core design pattern of `xiaozhi-server` to integrate different AI services, which greatly enhances the flexibility and scalability of the system. For each AI service type (ASR, TTS, LLM, VAD, Intent, Memory, VLLM), an abstract base class (ABC, Abstract Base Class) is defined in its corresponding subdirectory, such as `core/providers/asr/base.py`. This base class specifies the common interface methods that this type of service must implement (such as ASR's `async def transscribe(self, audio_chunk: bytes) -> str: pass`).
* **Specific implementation:** The implementation of various specific AI service providers or local models exists in the form of independent Python classes (for example, `core/providers/asr/fun_local.py` implements the logic of local FunASR, and `core/providers/llm/openai.py` implements the connection with the OpenAI GPT model). These concrete classes inherit from the corresponding abstract base class and implement the interface defined by it. Some providers also use DTOs (Data Transfer Objects, present in their respective `dto/` directories) to structure the data exchanged with external services.
* **Advantages:** Enables core business logic to call different AI services in a unified manner without caring about its underlying specific implementation. Users can easily switch AI service backends through configuration files. Adding support for new AI services has also become relatively simple, just implement the corresponding Provider interface.
* **Dynamic loading and initialization:** The `core/utils/modules_initialize.py` script plays the role of a factory. When the server starts, or when it receives a configuration update command, it will dynamically import and instantiate the corresponding Provider class based on the `selected_module` in the configuration file and the specific provider settings of each service.

2. **WebSocket communication and connection processing (`app.py`, `core/websocket_server.py`, `core/connection.py`):**
* **Server startup and entry (`app.py`):**
* `app.py` serves as the main entry and is responsible for initializing the application environment (such as checking FFmpeg, loading configuration, and setting logs).
* It will generate or load an `auth_key` (JWT key), which is used to protect a specific HTTP interface (such as the visual analysis interface `/mcp/vision/explain`). If `manager-api.secret` is empty in the configuration, a UUID will be generated as `auth_key`.
* Use `asyncio.create_task()` to start `WebSocketServer` (listening like `ws://0.0.0.0:8000/xiaozhi/v1/`) and `SimpleHttpServer` (listening like `http://0.0.0.0:8003/xiaozhi/ota/`) concurrently.
* Contains a `monitor_stdin()` coroutine, used to keep the application alive or handle terminal input under certain circumstances.
* **WebSocket Server Core (`core/websocket_server.py`):**
* The `WebSocketServer` class uses the `websockets` library to listen for connection requests from ESP32 devices.
* For each successful WebSocket connection, it will create an **independent `ConnectionHandler` instance** (presumably defined in `core/connection.py`). This design pattern of one handler instance per connection is the key to achieving multi-device state isolation and concurrent processing, ensuring that the conversation flow and contextual information of each device do not interfere with each other.
* The server also provides a `_http_response` method that allows a simple response (such as returning "Server is running") to non-WebSocket upgraded HTTP GET requests on the same port to facilitate health checks.
* **Dynamic configuration update:** `WebSocketServer` contains an `update_config()` asynchronous method. This method uses `config_lock` (an `asyncio.Lock`) to ensure atomicity of configuration updates. It calls `get_config_from_api()` (possibly implemented in `config_loader.py`, communicating with `manager-api` through `manage_api_client.py`) to get the new configuration. Use auxiliary functions such as `check_vad_update()` and `check_asr_update()` to determine whether a specific AI module needs to be reinitialized to avoid unnecessary overhead. The updated configuration will be used to call `initialize_modules()` again to achieve hot switching of the AI ​​service provider.

3. **Message processing and conversation flow control (`core/handle/` and `ConnectionHandler`):**
* `ConnectionHandler` (presumed) serves as the control center of each connection, responsible for receiving messages from ESP32 and distributing them to the corresponding processing modules in the `core/handle/` directory based on the message type or current conversation status. This modular processor design makes `ConnectionHandler` logic clearer and easier to expand.
* **Main processing modules and their responsibilities:**
* `helloHandle.py`: Handles the handshake protocol, device authentication or initialization information exchange when initially connecting to ESP32.
* `receiveAudioHandle.py`: Receive audio stream data, call VAD Provider for voice activity detection, and pass valid audio clips to ASR Provider for recognition.
* `textHandle.py` / `intentHandler.py`: After obtaining the text recognized by ASR, interact with the Intent Provider (possibly using LLM for intent recognition) and the LLM Provider to understand the user's intention and generate a preliminary reply or decision.
* `functionHandler.py`: When the response from LLM contains instructions to execute a specific "function call", this module is responsible for finding and executing the corresponding plug-in function from the plug-in registry.
* `sendAudioHandle.py`: Give the text reply finally generated by LLM to TTS Provider to synthesize speech, and send the audio stream back to ESP32 through WebSocket.
* `abortHandle.py`: Handle interrupt requests from ESP32, such as stopping the current TTS broadcast.
* `iotHandle.py`, `mcpHandle.py`: Handle specific instructions related to IoT device control or more complex Module Communication Protocol (MCP).

4. **Plug-in function expansion system (`plugins_func/`):**
* **Design Purpose:** Provide a standardized way to extend the functionality and "skills" of voice assistants without modifying the core code.
* **Implementation mechanism:**
* Each specific function exists in the `plugins_func/functions/` directory in the form of an independent Python script (such as `get_weather.py`, `hass_set_state.py` for Home Assistant integration).
* `loadplugins.py` is responsible for scanning and loading these plug-in modules when the server starts.
* `register.py` (or specific decorators/functions inside the plugin module) may be used to define metadata for each plugin function, including:
* **Function Name:** The identifier used when calling LLM.
* **Function Description (Description):** For LLM to understand the role of this function.
* **Parameters Schema:** Usually a JSON Schema that defines in detail the parameters required by the function, their types, whether they are required and their descriptions. This is the key to LLM being able to correctly generate function call parameters.
* **Execution process:** When LLM decides in its thinking process that it needs to call an external tool or function to obtain information or perform an operation, it will generate a structured "function call" request based on the pre-provided function pattern. `functionHandler.py` in `xiaozhi-server` captures this request, finds the corresponding Python function from the plug-in registry and executes it, and then returns the execution result to LLM, which then generates a natural language reply to the user based on the result.

5. **Configuration Management (`config/`):**
* **Loading mechanism:** `config_loader.py` (called through `settings.py`) is responsible for loading basic configuration from the `config.yaml` file in the root directory.
* **Remote configuration and merging:** Configuration can be pulled from the `manager-api` service through `manage_api_client.py` (using a library such as `aiohttp` to communicate with `manager-api`). Remote configuration usually overrides the setting of the same name in the local `config.yaml`, allowing dynamic adjustment of server behavior through the web interface.
* **Log system:** `logger.py` initializes the application log system (may use `loguru` or encapsulate the standard `logging` module, support adding tags through `logger.bind(tag=TAG)` for easy tracking and filtering).
* **Static resources:** The `config/assets/` directory stores static audio files used for system prompt sounds (such as device binding prompt sounds `bind_code.wav`, error prompt sounds, etc.).

6. **Auxiliary HTTP service (`core/http_server.py`):**
* Run a simple HTTP server in parallel with the WebSocket service to handle specific HTTP requests. The main function is to provide OTA (Over-The-Air) firmware update download service for ESP32 devices (through the `/xiaozhi/ota/` endpoint). In addition, it may also host other tool HTTP interfaces such as `/mcp/vision/explain` (visual analysis).

To sum up, `xiaozhi-server` is a highly modular, configuration-driven AI application server built using the modern Python asynchronous programming model. Its carefully designed Provider mode and plug-in architecture give it strong adaptability and scalability, allowing it to flexibly access different AI capabilities and support growing functional requirements.

---

### 3.2. `manager-api` (Management backend - Java Spring Boot implementation)

The `manager-api` component is a powerful backend service built using Java and Spring Boot framework, which serves as the central administration and configuration hub for the entire `xiaozhi-esp32-server` ecosystem.

* **Core Goal:**
* Provide a set of safe, stable, RESTful-compliant API interfaces for `manager-web` (Vue.js front-end), allowing administrators to easily manage users, devices, system configurations and other related resources.
* Acts as a centralized configuration data provider for `xiaozhi-server` (Python core AI engine), allowing `xiaozhi-server` instances to obtain their latest operating parameters when starting or running.
* Persistent storage of key data, such as: user account information, device registration details, AI service provider configuration (including API keys, selected service models, etc.), TTS tone parameters, and OTA firmware version information, etc.

* **Core technology stack:**
* **Java 21:** The JDK version used by the project ensures support for modern Java features.
* **Spring Boot 3:** As the core development framework, it greatly simplifies the creation and deployment of independent, production-level Spring applications. It provides key functions such as automatic configuration, embedded web server (Tomcat by default), dependency management, etc.
* **Spring MVC:** Module in the Spring framework for building web applications and RESTful APIs.
* **MyBatis-Plus:** An ORM (Object Relational Mapping) framework that enhances MyBatis. It simplifies database operations, provides powerful CRUD (Create, Delete, Modify and Check) functions, conditional constructors, code generators, etc., and can be well integrated with Spring Boot.
* **MySQL:** As the main back-end relational database, it is used to store all management data and configuration information that need to be persisted.
* **Druid (Alibaba Druid):** A powerful JDBC connection pool implementation that provides rich monitoring functions and excellent performance for efficient management of database connections.
* **Redis (via Spring Data Redis):** A high-performance in-memory data structure storage, often used to implement data caching (such as caching hotspot configuration data, user session information) to significantly improve the response speed of APIs.
* **Apache Shiro:** A mature and easy-to-use Java security framework that handles the authentication (user authentication) and authorization (API access control) needs of applications.
* **Liquibase:** An open source tool for tracking, managing, and applying database schéma (schema) changes. It allows developers to define and version database structure changes in a database-independent manner.
* **Knife4j:** An API document generation tool integrated with Swagger and enhanced UI, specially designed for Java MVC framework (especially Spring Boot). It can generate a beautiful and easy-to-interact API documentation interface (usually accessed through `/xiaozhi/doc.html`).
* **Maven:** Used for build automation and dependency management of projects.
* **Lombok:** A Java library that automatically generates boilerplate code such as constructors, getters/setters, equals/hashCode, and toString through annotations to reduce redundancy.
* **HuTool / Google Guava:** Provides a large number of utility classes to simplify common programming tasks.
* **Aliyun Dysmsapi:** Alibaba Cloud SMS Service SDK, used to integrate sending SMS functions (such as verification codes, notifications).

* **Key implementation details:**

1. **Modular project structure (`modules/` package):**
* The core business logic of `manager-api` is clearly divided into different modules in the `src/main/java/xiaozhi/modules/` directory. This way of dividing modules by functional areas (for example, `sys` is responsible for system management, `agent` is responsible for agent configuration, `device` is responsible for device management, `config` is responsible for providing configuration for `xiaozhi-server`, `security` is responsible for security, `timbre` is responsible for sound management, and `ota` is responsible for firmware upgrades) greatly improves the maintainability and scalability of the code.
* **Internal structure of each module:** Each business module usually follows the classic three-tier architecture or its variants:
* **Controller (control layer):** Located at `xiaozhi.modules.[module name].controller`.
* **Service (service layer):** Located at `xiaozhi.modules.[module name].service`.
* **DAO/Mapper (data access layer):** Located in `xiaozhi.modules.[module name].dao`.
* **Entity (entity class):** Located at `xiaozhi.modules.[module name].entity`.
* **DTO (Data Transfer Object):** Located in `xiaozhi.modules.[module name].dto`.

2. **Layered architecture implementation:**
* **Controller layer (`@RestController`):** These classes use Spring MVC annotations (such as `@GetMapping`, `@PostMapping`, etc.) to define API endpoints. They are responsible for receiving HTTP requests, deserializing the JSON data in the request body into DTO objects, calling the corresponding Service layer methods to process business logic, and finally serializing the return results of the Service layer into JSON and returning them to the client as HTTP responses.
* **Service layer (`@Service`):** These classes (usually a combination of interfaces and their implementation classes) encapsulate core business rules and operational processes. They may call one or more DAO/Mapper objects to interact with the database, and often use the `@Transactional` annotation to manage the atomicity of database transactions.
* **Data Access (DAO/Mapper) layer (MyBatis-Plus Mappers):** These are Java interfaces, inherited from the `BaseMapper<Entity>` interface provided by MyBatis-Plus. MyBatis-Plus will automatically provide standard CRUD methods for these interfaces. For more complex database queries, developers can implement them by defining methods in the Mapper interface and using annotations (such as `@Select`, `@Update`) or writing corresponding XML mapping files. For example, `UserMapper.selectById(userId)` will be automatically implemented by MyBatis-Plus.
* **Entity layer (`@TableName`, `@TableId` and other MyBatis-Plus annotations):** These POJO (Plain Old Java Objects) classes are directly mapped to the table structure in the database. Lombok's `@Data` annotation is often used to automatically generate getters/setters, etc.
* **DTO layer:** Used to transfer data between various layers, especially between the Controller layer and the Service layer, and in the request/response body of the API. Using DTO helps decouple the data structure of the API interface and the data structure of the database entity, making the API more stable.

3. **Common functions and configuration (`common/` package):**
* The `src/main/java/xiaozhi/common/` package provides a series of common components and configurations shared across modules:
* **Base class:** Such as `BaseDao`, `BaseEntity`, `BaseService`, `CrudService`, which provide common properties or methods for the corresponding components of each module.
* **Global configuration:** Includes `MybatisPlusConfig` (MyBatis-Plus configuration, such as paging plug-in, data permission plug-in, etc.), `RedisConfig` (Redis connection and serialization configuration), `SwaggerConfig` (Knife4j configuration), `AsyncConfig` (asynchronous task executor configuration).
* **Custom annotations:** For example, `@LogOperation` is used to record operation logs through AOP, and `@DataFilter` may be used to implement data range filtering.
* **AOP aspects:** Such as `RedisAspect` may be used to implement method-level caching logic.
* **Global exception handling:** `RenExceptionHandler` (using the `@ControllerAdvice` annotation) captures specific or all exceptions thrown in the application (such as custom `RenException`), and returns a uniformly formatted JSON error response to the client. `ErrorCode` defines standardized error codes.
* **Tool class:** Provides a variety of practical tools such as date conversion, JSON processing (Jackson), IP address acquisition, HTTP context operations, unified result encapsulation (`Result` class), etc.
* **Validation tools:** `ValidatorUtils` and `AssertUtils` are used to simplify parameter verification logic.
* **XSS Protection:** Components such as `XssFilter` are used to prevent cross-site scripting attacks.
* **MyBatis-Plus auto-fill:** `FieldMetaObjectHandler` is used to automatically fill in public fields such as `createTime`, `updateTime` when performing insert or update database operations.

4. **Security Mechanism (Apache Shiro):**
* Shiro's configuration (usually under `modules/security/config/` or `common/config/`) defines how user authentication and authorization are performed.
* **Realms (domain):** The custom Shiro Realm class is responsible for querying user information (user name, password, salt value) from the database for authentication, and obtaining the user's role and permission information for authorization decisions.
* **Filters:** Shiro filter chains are applied to protect API endpoints, ensuring that only authenticated users with sufficient permissions can access specific resources.
* **Session/Token Management:** Shiro manages user sessions. For RESTful APIs, stateless authentication may be implemented in combination with token mechanisms such as OAuth2 or JWT.

5. **Database version control (Liquibase):**
* Database table structure, index, initial data and other changes are defined and versioned through Liquibase's `changelog` file (usually in XML format). When the application starts, Liquibase automatically checks and applies the necessary database structure updates to ensure the consistency of the database structure in development, test and production environments.

6. **API Documentation:**
* The complete API interface document can be accessed at the following address: https://2662r3426b.vicp.fun/xiaozhi/doc.html
* This document is generated using Knife4j and provides detailed descriptions of all RESTful API endpoints, request/response examples, and online testing capabilities.

`manager-api` uses these carefully selected technologies and design patterns to build a Java backend service that is comprehensive, clear in structure, safe and reliable, and easy to maintain and expand. Its modular design is particularly suitable for handling complex systems with multiple management functional requirements.

---

### 3.3. `manager-web` (Web management front end - Vue.js implementation)

The `manager-web` component is a single page application (SPA - Single Page Application) built using the Vue.js 2 framework. It provides system administrators with a feature-rich, interactive and user-friendly graphical user interface for comprehensive management and configuration of the `xiaozhi-esp32-server` ecosystem.

* **Core Goal:**
* Provide a Web-based centralized control panel for administrators to operate and monitor the system.
* Implement convenient management of AI service providers (ASR, LLM, TTS, etc.) in `xiaozhi-server` and their related API keys or license configurations.
* Supports refined management of user accounts, roles and permissions.
* Provides registration, configuration and status viewing functions for ESP32 devices.
* Allows administrators to customize TTS sounds, manage OTA firmware update process, adjust system-level parameters and dictionary data, etc.
* As a graphical interactive front-end for various functions exposed by `manager-api`.

* **Core technology stack:**
* **Vue.js 2:** A progressive JavaScript framework for building user interfaces. Its core features include declarative rendering, componentized system, data binding, etc., which are very suitable for building complex SPA.
* **Vue CLI (`@vue/cli-service`):** The official command line tool of Vue.js, used to quickly build projects, run development servers (supports hot module replacement HMR), and build and package production environments (Webpack is integrated and configured internally).
* **Vue Router (`vue-router`):** Vue.js official routing manager. It is responsible for implementing navigation switching between different "pages" or view components within the SPA without reloading the entire HTML page, providing a smooth user experience.
* **Vuex (`vuex`):** Vue.js official state management model and library. It acts as a "central data store" for all components in the application and is used to manage global shared state (such as currently logged in user information, device list, application configuration, etc.), and is especially suitable for large and complex applications.
* **Element UI (`element-ui`):** A popular desktop UI component library based on Vue 2.0. It provides a large number of pre-designed and implemented components (such as forms, tables, dialog boxes, navigation menus, buttons, prompts, etc.) to help developers quickly build professional and consistent user interfaces.
* **JavaScript (ES6+):** The primary programming language for front-end logic implementation, developed using its modern features.
* **SCSS (Sassy CSS):** A CSS preprocessor that adds advanced features such as variables, nested rules, mixins, and inheritance to CSS, making CSS code easier to organize, maintain, and reuse.
* **HTTP client (Flyio or Axios via `vue-axios`):** Used to initiate asynchronous HTTP (AJAX) requests to the `manager-api` backend on the browser side to obtain data or submit operations.
* **Webpack:** A powerful module packaging tool (managed and configured under the hood by Vue CLI). It treats various resources in the project (JavaScript files, CSS, images, fonts, etc.) as modules and packages them into static files that can be recognized by browsers.
* **Workbox (via `workbox-webpack-plugin`):** A library developed by Google to simplify the writing of Service Workers and the implementation of PWA (Progressive Web App - Progressive Web Application). It can help generate Service Worker scripts and implement functions such as resource caching and offline access.
* **Opus libraries (`opus-decoder`, `opus-recorder`):** These audio processing libraries indicate that the front end may have some capabilities for processing Opus format audio directly in the browser, for example: for testing microphone input, allowing administrators to record custom audio clips (perhaps for TTS tone samples or voice command testing), or playing Opus encoded audio previewed in the admin interface.

* **Key implementation details:**

1. **Single Page Application (SPA) Structure:**
* The entire front-end application loads a main HTML file (`public/index.html`). All subsequent page switching and content updates are dynamically completed on the client side by Vue Router, without the need to request a new HTML page from the server every time. This mode provides faster page loading and a smoother interactive experience.

2. **Component-Based Architecture:**
* The user interface is composed of a series of reusable Vue components (`.vue` single file components), forming a component tree. This approach improves the modularity, maintainability and reusability of the code.
* **`src/main.js`:** The entry JS file of the application. It is responsible for creating and initializing the root Vue instance, registering global plug-ins (such as Vue Router, Vuex, Element UI), and mounting the root Vue instance to a DOM element in `public/index.html` (usually `#app`).
* **`src/App.vue`:** The root component of the application. It usually defines the basic layout structure of the application (such as navigation bar, sidebar, main content area), and displays the view components matched by the current route through the `<router-view></router-view>` tag.
* **View components (`src/views/`):** These components represent each "page" or main functional area in the application (such as `Login.vue` login page, `DeviceManagement.vue` device management page, `UserManagement.vue` user management page, `ModelConfig.vue` model configuration page). They are usually mapped directly by Vue Router.
* **Reusable UI components (`src/components/`):** Contains smaller-grained UI components that are shared between different views (such as `HeaderBar.vue` top navigation bar, `AddDeviceDialog.vue` add device dialog, `AudioPlayer.vue` audio player component).

3. **Client routing (`src/router/index.js`):**
* Vue Router is configured in this file and defines the application's routing table. Each routing rule maps a specific URL path to a view component.
* Often includes **Navigation Guards**, such as the `beforeEach` guard, which is used to execute logic before the route jumps, such as checking whether the user is logged in, and redirecting to the login page if not logged in, thereby protecting pages that require authentication to access.

4. **State management (`src/store/index.js`):**
* Vuex is used to build a centralized state management center (Store). This Store contains:
* **State:** Stores application-level shared data (e.g., details of the currently logged in user, device list obtained from API, system configuration, etc.).
* **Getters:** Similar to the calculated properties in Vue components, it is used to derive some state values ​​from State for the convenience of component use.
* **Mutations:** **The only** method that can synchronously modify the data in State. They must be synchronous functions.
* **Actions:** Used to handle asynchronous operations (such as API calls) or encapsulate multiple Mutation submissions. Actions will call the API, obtain the data, and update the State through `commit` one or more Mutation.
* For example, when a user logs in, an Action named `login` may be called, which will send a login request to the back-end API. After success, the user information and token are obtained, and then `commit` is used. A Mutation named `SET_USER_INFO` is used to update the user information and token in the State.

5. **API communication (`src/apis/`):**
* All HTTP communication logic with the `manager-api` backend is encapsulated in the `src/apis/` directory, usually organized according to the modules of the backend API (such as `src/apis/module/agent.js`, `src/apis/module/device.js`).
* Each module exports a series of functions, each function corresponds to a specific API request. These functions internally use configured HTTP client instances (for example, uniformly configure Axios or Flyio instances in `src/apis/api.js` or `src/apis/httpRequest.js`, which may include setting request base addresses, request/response interceptors, etc.).
* **Interceptors:** HTTP client request interceptors are often used to automatically add authentication tokens (such as JWT) before each request is sent; response interceptors can be used to globally handle API errors (such as insufficient permissions, server errors) or to preprocess response data.

6. **Styles and Resources (`src/styles/`, `src/assets/`):**
* `Element UI` provides basic component styles.
* The `src/styles/global.scss` file is used to define globally shared SCSS styles, variables, mixins, etc.
* The `<style scoped>` tag inside a Vue single-file component allows you to write local styles that only apply to the current component.
* The `src/assets/` directory stores static resources such as images and fonts.

7. **Building and PWA features:**
* Vue CLI uses Webpack to package all code and resources into optimized static files for production deployment.
* The use of `workbox-webpack-plugin` (reflected in `service-worker.js` and `registerServiceWorker.js` files) indicates that the project integrates Service Worker technology. Service Worker can intercept network requests, implement intelligent caching of front-end resources (thus speeding up subsequent access), and even provide certain offline access capabilities when the network is disconnected. It is one of the core technologies of PWA.

8. **Environment configuration (`.env` series files):**
* The `.env` (and `.env.development`, `.env.production`, etc.) files in the project root directory are used to define environment variables. These variables (such as `VUE_APP_API_BASE_URL` to specify the base URL of the `manager-api`) can be accessed from application code in the form of `process.env.VUE_APP_XXX`, allowing different parameters to be configured for different build environments (development, test, production).

Through the comprehensive use of these technologies, `manager-web` builds a powerful, easy-to-maintain and user-experience management interface, providing solid front-end support for the configuration and monitoring of the `xiaozhi-esp32-server` system.

---

### 3.4. `manager-mobile` (Smart console mobile version - uni-app implementation)

The `manager-mobile` component is a cross-end mobile management terminal based on uni-app v3 + Vue 3 + Vite, supporting App (Android & iOS) and WeChat applet. It provides system administrators with a mobile management interface, making management operations more convenient.

* **Core Goal:**
* Provides a convenient management interface on mobile devices, which is similar to manager-web but optimized for mobile devices.
* Supports core functions such as user login, device management, and AI service configuration.
* Cross-platform adaptation, one set of code can run on iOS, Android and WeChat mini programs at the same time.
* Provide mobile users with a smooth and efficient management experience.

* **Platform Compatibility:**

| H5 | iOS | Android | WeChat Mini Program |
| -- | --- | ------- | ---------- | 
| √  | √   | √       | √          | 

* **Core technology stack:**
* **uni-app v3:** A framework for developing all front-end applications using Vue.js, supporting iOS, Android, H5, and various small programs.
* **Vue 3:** A progressive framework for building user interfaces, providing better performance and new features.
* **Vite:** The next generation of front-end development and construction tools, providing an extremely fast development experience.
* **pnpm:** Fast, disk space-saving package manager.
* **alova:** A lightweight and flexible request strategy library, matched with @alova/adapter-uniapp to adapt to the uni-app environment.
* **pinia:** Vue's state management library, replacing Vuex, provides a simpler API and better TypeScript support.
* **UnoCSS:** A high-performance and extremely flexible on-the-fly atomic CSS engine.
* **TypeScript:** Provides a type-safe development experience.

* **Key implementation details:**

1. **Cross-platform architecture:**
* Based on the uni-app framework, it achieves the goal of running a set of codes on multiple terminals, greatly reducing development and maintenance costs.
* Based on the characteristics and limitations of different platforms, perform platform-specific code processing through conditional compilation.

2. **Project Structure:**
* **`src/App.vue`:** The root component of the application, which defines global styles and configurations.
* **`src/main.ts`:** The entry file of the application, responsible for initializing the Vue instance, registering plug-ins and routing interceptors.
* **`src/pages/`:** Stores the page components of the application, such as login page, device management page, etc.
* **`src/layouts/`:** Define the layout components of the application, such as default layout, layout with tabbar, etc.
* **`src/api/`:** Encapsulates the communication logic with the back-end API.
* **`src/store/`:** Use pinia for state management.
* **`src/components/`:** stores reusable components.
* **`src/utils/`:** Provides general utility functions.

3. **Network request:**
* Implement network requests based on alova + @alova/adapter-uniapp, and uniformly handle request headers, authentication, errors, etc.
* The request address and environment configuration are managed through .env files, supporting switching between different environments.

4. **Routing and Authentication:**
* Use uni-app's routing system and combine it with routing interceptors to implement page login verification and permission control.
* When non-logged-in users access a page that requires authentication, they will be redirected to the login page.

5. **Status Management:**
* Use pinia to manage application status, such as user information, device list, etc.
* Implement persistent storage of state through the pinia-plugin-persistedstate plug-in.

6. **Build and Release:**
* Supports a variety of build commands, such as building WeChat applets, Android and iOS Apps, etc.
* Use HBuilderX for cloud packaging of apps, simplifying the packaging process.

Through the application of these technologies, `manager-mobile` provides users with a mobile management tool with complete functions and smooth experience, allowing administrators to manage and configure the system anytime and anywhere.

---

## 4. Data flow and interaction mechanism

The `xiaozhi-esp32-server` system works together through clearly defined data flows and interaction protocols between components. The main communication method relies on the WebSocket protocol optimized for real-time interaction and the RESTful API for client-server requests.

**4.1. Core voice interaction process (ESP32 device <-> `xiaozhi-server`)**

This process is real-time and mainly uses WebSocket for low-latency, two-way data exchange.

* **Communication protocol document:**
* Detailed communication protocol documentation can be accessed at the following address: https://ccnphfhqs21z.feishu.cn/wiki/M0XiwldO9iJwHikpXD5cEx71nKh
* This document describes in detail the WebSocket communication protocol between the ESP32 device and `xiaozhi-server`, including:
* Connection establishment and handshake process
* Audio data transmission format
*Control command format
*Status report format
* Error handling mechanism

* **Connection establishment and handshake:**
* The ESP32 device, as a client, actively initiates a WebSocket connection request to the specified endpoint of `xiaozhi-server` (for example, `ws://<server IP>:<WebSocket port>/xiaozhi/v1/`).
* `xiaozhi-server` (`core/websocket_server.py`) receives the connection and instantiates an independent `ConnectionHandler` object for each successfully connected ESP32 device to manage the entire life cycle of the session.
* After the connection is established, an initial handshake process (handled by `core/handle/helloHandle.py`) may be performed to exchange device identification, authentication information, protocol versions, or basic status.

* **Audio uplink transmission (ESP32 -> `xiaozhi-server`):**
* After the user speaks into the ESP32 device, the microphone on the device captures raw audio data (usually PCM or a compressed format such as Opus).
* ESP32 pushes these audio data chunks (chunks) as WebSocket **binary messages** in real time to the `ConnectionHandler` corresponding to `xiaozhi-server`.
* The server-side `core/handle/receiveAudioHandle.py` module is responsible for receiving, buffering and processing these audio data.

* **AI core processing (inside `xiaozhi-server`):**
* **VAD (Voice Activity Detection):** `receiveAudioHandle.py` utilizes a configured VAD provider (such as SileroVAD) to analyze the audio stream to accurately identify the start and end points of speech and filter out silence or noise segments.
* **ASR (Automatic Speech Recognition):** The detected valid speech segments are sent to the configured ASR provider (local such as FunASR, or cloud service). The ASR engine converts audio signals into text strings.
* **NLU/LLM (Natural Language Understanding/Large Language Model):** The text output by ASR is passed to the configured LLM provider, along with the current conversation context history obtained from the Memory provider, and the description schema of the available functions (tools) loaded from `plugins_func/`.
* **Function call execution (if required for LLM decision-making):** If LLM determines that an external function needs to be called (such as querying the weather, controlling home appliances) after analysis, it will generate a structured function call request. `core/handle/functionHandler.py` receives this request, finds and executes the corresponding Python function defined in `plugins_func/`, and returns the execution result of the function to LLM. The LLM then generates a final natural language response based on this result.
* **Response generation:** LLM synthesizes all information (user input, context, function call results, etc.) to generate the final text reply.
* **Memory Update:** The current round of interactions (user questions, LLM responses, possible function calls) will be processed by the Memory provider to update the conversation history for subsequent interactions.
* **TTS (Text to Speech):** The final text reply generated by LLM is sent to the configured TTS provider, which synthesizes the text into a speech data stream (such as MP3 or WAV format).

* **Audio downlink response (`xiaozhi-server` -> ESP32):**
* The voice data stream synthesized by the TTS provider is sent back to the ESP32 device in real time as a **binary message** of WebSocket through the `core/handle/sendAudioHandle.py` module.
* The ESP32 device receives these chunks of audio data and plays them immediately through the speakers to the user.

* **Control and status messages (bidirectional):**
* In addition to audio streams, **text messages** are also exchanged between ESP32 and `xiaozhi-server` through WebSocket. These messages are usually encapsulated in JSON format.
* **ESP32 -> Server:** The device may send status reports (such as network status, microphone status), error codes, or specific control commands (such as "stop TTS broadcast" triggered by user keystrokes).
* **Server -> ESP32:** The server may send control instructions to the device (such as "start listening", "stop listening", adjust sensitivity, and issue specific configuration parameters).
* Modules such as `core/handle/abortHandle.py` (handling interrupt requests), `core/handle/reportHandle.py` (handling device reports) are responsible for parsing and responding to these control/status messages.

**4.2. Management and configuration process (`manager-web` <-> `manager-api` <-> `xiaozhi-server`)**

This process mainly relies on the RESTful API based on HTTP/HTTPS for request-response interaction.

* **Manager UI backend interaction (`manager-web` -> `manager-api`):**
* When the administrator performs an operation in the `manager-web` interface (such as saving a configuration, adding a new user, registering an ESP32 device):
* The Vue.js front-end application (`manager-web`) will initiate an asynchronous HTTP request (usually GET, POST, PUT, DELETE) to the corresponding REST API endpoint of `manager-api` through its API encapsulation module (located in `src/apis/module/`).
* The request body and response body usually use JSON format.
* The `@RestController` class in `manager-api` receives these requests. The **Apache Shiro** framework will first perform authentication and authorization checks on the request.
* After passing the verification, the Controller distributes the request to the corresponding Service layer to process the business logic. The Service layer may interact with a MySQL database (via MyBatis-Plus) and may utilize Redis for data caching.
* After processing is completed, `manager-api` returns an HTTP response in JSON format to `manager-web`.
* `manager-web` updates its Vuex state storage and user interface display based on the response results.

* **Configuration synchronization (`manager-api` -> `xiaozhi-server`):**
* The operation of `xiaozhi-server` depends on the dynamic configuration obtained from `manager-api` (such as the currently selected AI service provider and its API key).
* **Pull Mechanism:** The `config/manage_api_client.py` module inside `xiaozhi-server` will initiate an HTTP GET request to a specified endpoint of `manager-api` (for example, provided by a Controller in `modules/config/controller/`) when the server starts or through a specific update trigger (for example, `WebSocketServer.update_config()` is called).
* `manager-api` responds to the request and returns the configuration data (JSON format) required by `xiaozhi-server`.
* After `xiaozhi-server` receives the configuration, it will update its internal state and may reinitialize the related AI service module to make the new configuration take effect.

* **OTA firmware update process (conceptual description):**
* Administrators upload new ESP32 firmware packages to the specific endpoint of `manager-api` through the `manager-web` interface.
* `manager-api` stores firmware files and records relevant metadata (version number, applicable device model, etc.).
* When an administrator triggers an OTA update for a specific device:
* `manager-api` may notify `xiaozhi-server` (the specific notification mechanism may be a polling checkpoint, or `xiaozhi-server` exposes an API for receiving update notifications, or something more loosely coupled such as a message queue).
* `xiaozhi-server` can then send a command message containing the firmware download URL to the target ESP32 device via WebSocket.
* After receiving the instruction, the ESP32 device downloads the firmware from this URL through an HTTP GET request. This URL may point to the path served by `SimpleHttpServer` running on `xiaozhi-server` itself (such as `/xiaozhi/ota/`), or in some architectures, it may point directly to `manager-api` or a dedicated file server.

**4.3. Summary of main agreements:**

* **WebSocket:** was selected for the communication link between ESP32 and `xiaozhi-server` because it is very suitable for real-time, low-latency, two-way data streaming (especially audio), and the delivery of asynchronous control messages.
* **RESTful APIs (based on HTTP/HTTPS, usually using JSON as the data exchange format):** This is the standard way of communicating between web services. Used for request-response interaction between `manager-web` (client) and `manager-api` (server), and also used for `xiaozhi-server` (as client) to pull configuration information from `manager-api` (as server). Its stateless nature, extensive library support, and easy-to-understand semantics make it ideal for this type of interaction.

This multi-protocol communication strategy ensures that different types of interaction requirements within the system can be handled efficiently and appropriately, taking into account real-time and standardized request-response patterns.

---

## 5. Summary of core functions

The `xiaozhi-esp32-server` system provides a rich set of features designed to support developers in building advanced voice control applications:

1. **Comprehensive voice interaction backend:** Provides an end-to-end solution from voice capture guidance to response generation and action execution.
2. **Modular and pluggable AI services:**
* Supports a wide range of ASR (Automatic Speech Recognition), LLM (Large Scale Language Model), TTS (Text to Speech), VAD (Voice Activity Detection), Intent Recognition and Memory providers.
* Allows dynamic selection and configuration of these services (including cloud-based APIs and on-premises models) to balance cost, performance, privacy and language needs.
3. **Advanced Conversation Management:**
* Supports natural interaction, with functions such as wake word-initiated dialogue, manual (button-to-talk) dialogue, and real-time interruption of system responses.
* Contains contextual memory to maintain coherence across multiple rounds of conversations.
* Features automatic sleep mode after a period of inactivity.
4. **Multi-language capabilities:**
* Supports recognition and synthesis in multiple languages, including Mandarin, Cantonese, English, Japanese and Korean (depending on the selected ASR/LLM/TTS provider).
5. **Extensible functions achieved through plug-ins:**
* A powerful plug-in system allows developers to add custom "skills" or functions (e.g., get weather, control smart home devices, access news).
* These functions can be triggered by LLM using its function calling capabilities, based on the provided pattern.
* Built-in support for Home Assistant integration.
6. **IoT device control:**
* Designed to manage and control smart home devices and other IoT hardware via voice commands and utilize a plug-in system.
7. **Web-based management console (`manager-web` & `manager-api`):**
* Provides a comprehensive graphical interface for:
* System configuration (AI service selection, API key, operating parameters).
* User management with role-based access control.
* ESP32 device registration and management.
* Voice timbre/TTS voice customization.
* OTA (over the air) firmware update management for ESP32 devices.
* Management of system parameters and dictionaries.
8. **Flexible Deployment Options:**
* Supports deployment via Docker containers (for simplified server-only or full-stack setups) and directly from source to suit a variety of environments and user expertise.
9. **Dynamic remote configuration:**
* `xiaozhi-server` can obtain its configuration from `manager-api`, allowing real-time updates of AI providers and settings without restarting the server.
10. **Open Source and Community Driven:**
* Licensed under the MIT License, which encourages transparency, collaboration and community contribution.
11. **Cost-effective solution:**
* Provides a "Getting Started with All-Free Setup" path, leveraging the free tier of AI services or local models, making it easy to conduct experiments and personal projects.
12. **Progressive Web App (PWA) Features:**
* The `manager-web` control panel includes Service Worker integration for enhanced caching and potential offline access.
13. **Detailed API documentation:**
* `manager-api` provides OpenAPI (Swagger) documentation via Knife4j for clear understanding and testing of its RESTful endpoints.

Together these features make `xiaozhi-esp32-server` a powerful, adaptable and user-friendly platform for building complex voice interaction applications.

---

## 6. Deployment and Configuration Overview

The `xiaozhi-esp32-server` system is designed with flexibility in mind, providing multiple deployment methods and comprehensive configuration options to adapt to different usage scenarios and needs.

**Deployment options:**

Projects can be deployed in a variety of ways, primarily including using Docker to simplify the installation process, or deploying directly from source code for greater control and development.

1. **Docker-based deployment:**
* **Simplified Installation (`xiaozhi-server` only):** This option only deploys the core Python-based `xiaozhi-server`. It is suitable for users who mainly need voice AI processing power and IoT control, but do not need a complete web management interface and database support functions (such as OTA). In this mode, configuration is usually managed through a local file (`config.yaml`), but it can still be pointed to an existing `manager-api` instance if needed.
* **Full module installation (all components):** This solution deploys all core components: `xiaozhi-server`, Java-based `manager-api`, and Vue.js-based `manager-web`, and also includes the required database services (MySQL and Redis). This provides a complete system experience, including a web control panel for comprehensive configuration and management.
* The project provides a `Dockerfile` definition for each service, and uses the `docker-compose.yml` file (for example, `docker-compose.yml` for the basic version, `docker-compose_all.yml` for the full-featured version) to orchestrate and manage the deployment of multiple containers. In addition, a `docker-setup.sh` script may also be provided to assist in automating part of the Docker environment setup.

2. **Source code deployment:**
* This method requires manually setting up the corresponding development environment for each component: Python environment for `xiaozhi-server`, Java/Maven environment for `manager-api`, Node.js/Vue CLI environment for `manager-web`.
* For full module installation, you also need to manually install and configure MySQL and Redis database services.
* This method is usually used for project development, in-depth customization, debugging, or in production scenarios that have special requirements for the environment.

**Configuration Management:**

Configuration is key to customizing system behavior, especially when it comes to selecting an AI service provider and managing API keys.

1. **`xiaozhi-server` configuration:**
* **Local `config.yaml`:** A main YAML format configuration file located in the root directory of `xiaozhi-server`. It defines the server port, selected AI service provider (ASR, LLM, TTS, VAD, intent recognition, memory module, etc.), their respective API key or model path, plugin configuration, log level, etc.
* **Remote configuration through `manager-api`:** `xiaozhi-server` is designed to obtain its running configuration from `manager-api`. Settings obtained from `manager-api` usually override settings of the same name in the local `config.yaml`. This brings two major benefits:
* **Centralized management:** All configurations can be managed centrally through the `manager-web` interface.
* **Dynamic Updates:** `xiaozhi-server` can refresh its configuration and re-initialize the AI ​​module without completely restarting the service.
* `config/config_loader.py` and `config/manage_api_client.py` in `xiaozhi-server` are responsible for handling the logic of loading, merging and pulling configurations from `manager-api`.

2. **`manager-api` configuration:**
* As a Spring Boot application, its configuration is mainly managed through the `application.properties` or `application.yml` files located in the `src/main/resources` directory.
* Key configuration items include: database connection information (MySQL URL, username, password), Redis server address and port, application service port (default is 8002), Apache Shiro security-related settings, and configuration parameters of any integrated third-party services (such as Alibaba Cloud SMS).

3. **`manager-web` configuration:**
* The environment-specific settings of the Vue.js front-end application are managed through the `.env` series of files (such as `.env`, `.env.development`, `.env.production`) in the project root directory.
* The most critical configuration here is usually the API base URL address of the `manager-api` backend (such as `VUE_APP_API_BASE_URL`), to which the front-end application will send all API requests.

4. **Predefined configuration scheme:**
* Some common configuration combinations will be recommended in the project document (usually README), such as:
* **"Getting started with all-free setup":** This plan is designed to utilize the free package quota of cloud AI services or the completely free on-premises model to minimize the user's initial usage costs and operating expenses.
* **"Full streaming configuration":** This solution gives priority to the system's response speed and the smoothness of interaction, and usually chooses a (possibly paid) AI service that supports streaming processing.
* These predefined schemes provide guidance for users to configure AI service providers in `xiaozhi-server` (through the `manager-web` interface or directly modify `config.yaml`).

In the case of full module deployment, it is recommended to use the `manager-web` control panel as the main operation interface for most configuration tasks, as it provides a user-friendly way to manage various settings persisted by `manager-api` and ultimately used by `xiaozhi-server`.

---
